name: Deploy

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      version:
        description: 'Version to deploy (tag or branch)'
        required: true
        default: 'main'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.setup.outputs.environment }}
      version: ${{ steps.setup.outputs.version }}
      image_tag: ${{ steps.setup.outputs.image_tag }}
    
    steps:
    - name: Setup deployment parameters
      id: setup
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          echo "image_tag=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
        else
          echo "environment=production" >> $GITHUB_OUTPUT
          echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          echo "image_tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        fi

  deploy-staging:
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.environment == 'staging'
    environment: 
      name: staging
      url: https://staging.vislang.example.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-west-2
        
    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --name vislang-staging --region us-west-2
        
    - name: Deploy to staging
      run: |
        envsubst < deployment/k8s/staging/deployment.yaml | kubectl apply -f -
        kubectl set image deployment/vislang-app \
          vislang-app=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.image_tag }} \
          -n vislang-staging
        kubectl rollout status deployment/vislang-app -n vislang-staging --timeout=600s
      env:
        IMAGE_TAG: ${{ needs.prepare.outputs.image_tag }}
        ENVIRONMENT: staging
        
    - name: Run deployment tests
      run: |
        kubectl run deployment-test \
          --image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.image_tag }} \
          --rm -i --restart=Never \
          -n vislang-staging \
          -- python -m pytest tests/deployment/ -v
          
    - name: Health check
      run: |
        # Wait for deployment to be ready
        kubectl wait --for=condition=available --timeout=300s deployment/vislang-app -n vislang-staging
        
        # Get service URL
        SERVICE_IP=$(kubectl get service vislang-service -n vislang-staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        
        # Health check
        curl -f "http://${SERVICE_IP}/health" || exit 1
        
        echo "Staging deployment successful!"
        echo "Service available at: http://${SERVICE_IP}"

  deploy-production:
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.environment == 'production'
    environment: 
      name: production
      url: https://vislang.example.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-west-2
        
    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --name vislang-production --region us-west-2
        
    - name: Pre-deployment backup
      run: |
        # Backup database
        kubectl exec deployment/postgres -n vislang-production -- \
          pg_dump -U vislang vislang_db > backup-$(date +%Y%m%d-%H%M%S).sql
          
        # Upload backup to S3
        aws s3 cp backup-*.sql s3://vislang-backups/pre-deployment/
        
    - name: Deploy to production (Blue-Green)
      run: |
        # Deploy to green environment
        envsubst < deployment/k8s/production/deployment-green.yaml | kubectl apply -f -
        kubectl set image deployment/vislang-app-green \
          vislang-app=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.image_tag }} \
          -n vislang-production
        kubectl rollout status deployment/vislang-app-green -n vislang-production --timeout=600s
      env:
        IMAGE_TAG: ${{ needs.prepare.outputs.image_tag }}
        ENVIRONMENT: production
        
    - name: Production smoke tests
      run: |
        # Get green service URL
        GREEN_SERVICE_IP=$(kubectl get service vislang-service-green -n vislang-production -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        
        # Run smoke tests against green deployment
        kubectl run production-smoke-test \
          --image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.image_tag }} \
          --rm -i --restart=Never \
          -n vislang-production \
          --env="TARGET_URL=http://${GREEN_SERVICE_IP}" \
          -- python -m pytest tests/smoke/ -v
          
    - name: Switch traffic to green (Blue-Green cutover)
      run: |
        # Update service selector to point to green deployment
        kubectl patch service vislang-service -n vislang-production \
          -p '{"spec":{"selector":{"version":"green"}}}'
          
        echo "Traffic switched to green deployment"
        
    - name: Post-deployment verification
      run: |
        # Wait for traffic switch
        sleep 30
        
        # Health check on main service
        MAIN_SERVICE_IP=$(kubectl get service vislang-service -n vislang-production -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        curl -f "http://${MAIN_SERVICE_IP}/health" || exit 1
        
        # Run full verification suite
        kubectl run production-verification \
          --image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.image_tag }} \
          --rm -i --restart=Never \
          -n vislang-production \
          --env="TARGET_URL=http://${MAIN_SERVICE_IP}" \
          -- python -m pytest tests/verification/ -v
          
    - name: Cleanup old blue deployment
      run: |
        # Scale down blue deployment
        kubectl scale deployment vislang-app-blue --replicas=0 -n vislang-production
        
        # Keep blue deployment for quick rollback if needed
        echo "Blue deployment scaled down but preserved for rollback"
        
    - name: Update deployment status
      run: |
        # Create deployment record
        kubectl create configmap deployment-record-$(date +%Y%m%d-%H%M%S) \
          --from-literal=version=${{ needs.prepare.outputs.image_tag }} \
          --from-literal=timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ) \
          --from-literal=commit=${{ github.sha }} \
          -n vislang-production
          
        echo "Production deployment successful!"
        echo "Version: ${{ needs.prepare.outputs.image_tag }}"

  rollback:
    runs-on: ubuntu-latest
    if: failure() && needs.prepare.outputs.environment == 'production'
    needs: [prepare, deploy-production]
    environment: production
    
    steps:
    - name: Emergency rollback
      run: |
        echo "Initiating emergency rollback..."
        
        # Switch traffic back to blue
        kubectl patch service vislang-service -n vislang-production \
          -p '{"spec":{"selector":{"version":"blue"}}}'
          
        # Scale blue deployment back up
        kubectl scale deployment vislang-app-blue --replicas=3 -n vislang-production
        
        # Wait for blue deployment to be ready
        kubectl rollout status deployment/vislang-app-blue -n vislang-production --timeout=300s
        
        echo "Rollback completed. Service restored to previous version."
        
    - name: Create incident issue
      uses: actions/github-script@v7
      with:
        script: |
          github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: 'Production Deployment Failed - Emergency Rollback Executed',
            body: `Production deployment failed and emergency rollback was executed.\n\n**Details:**\n- Version: ${{ needs.prepare.outputs.image_tag }}\n- Workflow: ${context.workflow}\n- Run: ${context.runId}\n\n**Action Required:**\n- [ ] Investigate deployment failure\n- [ ] Fix issues in staging\n- [ ] Plan new deployment\n- [ ] Update incident documentation`,
            labels: ['incident', 'production', 'deployment', 'urgent'],
            assignees: ['devops-team']
          })

  notify:
    runs-on: ubuntu-latest
    needs: [prepare, deploy-staging, deploy-production]
    if: always()
    
    steps:
    - name: Notify deployment status
      uses: actions/github-script@v7
      with:
        script: |
          const environment = '${{ needs.prepare.outputs.environment }}';
          const version = '${{ needs.prepare.outputs.image_tag }}';
          const success = '${{ needs.deploy-staging.result }}${{ needs.deploy-production.result }}' === 'success';
          
          const status = success ? '✅ SUCCESS' : '❌ FAILED';
          const color = success ? 'good' : 'danger';
          
          // Slack notification (if webhook configured)
          if (process.env.SLACK_WEBHOOK) {
            const payload = {
              text: `Deployment ${status}`,
              attachments: [{
                color: color,
                fields: [
                  { title: 'Environment', value: environment, short: true },
                  { title: 'Version', value: version, short: true },
                  { title: 'Workflow', value: '${{ github.workflow }}', short: true },
                  { title: 'Run', value: '${{ github.run_id }}', short: true }
                ]
              }]
            };
            
            await fetch(process.env.SLACK_WEBHOOK, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
          }
      env:
        SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}